# VINS论文的IMU预积分

VINS中的与积分也参考了Forster论文中的预积分，只是形式有所区别。

https://blog.csdn.net/qq_43525734/article/details/90167688

## 1. IMU

### 测量模型

IMU 测量方程忽略地球旋转，IMU 测量方程为：

![image-20210904084524648](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904084524648.png)

其中噪声项服从高斯白噪声，偏移量bias为随机游走，其导数也服从高斯白噪声。

![image-20210904092109332](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904092109332.png)

### 运动模型 -> PVQ信息

#### （1）IMU integration in world frame

#### 当前时刻 PVQ 的连续形式

由上面的 IMU 测量方程积分就可以计算出下一时刻的位置、速度和旋转（PVQ），连续状态下，将第 k 帧和第 k+1 帧之间的所有 IMU 进行积分，可得第 k+1 帧的PVQ，作为视觉估计的初始值：

式1：

![image-20210904095551955](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904095551955.png)

![image-20210904085336808](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904085336808.png)

其中，$\hat a_t$和$\hat w_t$为 IMU 测量的加速度和角速度，是在 Body 自身坐标系，world 坐标系是 IMU 所在的惯导系。

#### 当前时刻 PVQ 的中值法离散形式

公式(1)给出的是连续时刻的相机当前 PVQ 的迭代公式，而代码中使用离散状态下基于中值法的公式，即从第 i 个 IMU 时刻到第 i+1 个 IMU 时刻的积分过程，这与 Estimator::processIMU()函数中的 Ps[j]、Rs[j]和 Vs[j]是一致的（代码中的 j 时刻即为此处的 i+1）：

![image-20210904185731195](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904185731195.png)

其中：

![image-20210904185743186](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904185743186.png)

### 预积分计算 -> PVQ增量

#### （2）IMU integration in the body frame of first pose of interests

#### 两帧之间 PVQ 增量的连续形式

为避免重新传播 IMU 观测值，选用 IMU 预积分模型，从世界坐标系转为本体坐标系。

通过观察公式(1)可知，IMU 的预积分需要依赖与第 k 帧的 v 和 R，当我们在后端进行 非线性优化时，需要迭代更新第 k 帧的 v 和 R，这将导致我们需要根据每次迭代后值重新进 行积分，这将非常耗时。因此，我们考虑将优化变量从第 k 帧到第 k+1 帧的 IMU 预积分项 中分离开来，通过对公式（1）左右两侧各乘$R^{b_k}_{W}$，可简化为 式2：

![image-20210904095818595](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904095818595.png)

其中 式3：

![image-20210904085648510](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904085648510.png)

此时式3就是连续时刻的 IMU 预积分公式，可以发现得到的 IMU 预积分的值只与不同时刻的IMU测量值$\hat a_t$和$\hat w_t$有关。

#### 两帧之间 PVQ 增量的中值法离散形式

预积分 IMU 测量模型（估计值）为：

![image-20210904095858473](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904095858473.png)



离散状态下PVQ增量采用中值法积分的预积分方程（预积分测量值）为：

![image-20210904100119175](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904100119175.png)

注意这里跟式1是不一样的，这里积分出来的是前后两帧之间的 IMU 增量信息，而式1给出的当前帧时刻的物理量信息。

其中：

![image-20210904100149395](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904100149395.png)

该公式对应于代码中midPointIntegration部分：

```
Vector3d un_gyr = 0.5 * (_gyr_0 + _gyr_1) - linearized_bg;
result_delta_q = delta_q * Quaterniond(1, un_gyr(0) * _dt / 2, un_gyr(1) * _dt / 2, un_gyr(2) * _dt / 2);

Vector3d un_acc_0 = delta_q * (_acc_0 - linearized_ba);
Vector3d un_acc_1 = result_delta_q * (_acc_1 - linearized_ba);
Vector3d un_acc = 0.5 * (un_acc_0 + un_acc_1);

result_delta_p = delta_p + delta_v * _dt + 0.5 * un_acc * _dt * _dt;
result_delta_v = delta_v + un_acc * _dt;

// 预积分的过程中Bias没有发生改变
result_linearized_ba = linearized_ba;
result_linearized_bg = linearized_bg;
```



### IMU误差状态方程

误差状态向量

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095206957.jpg)

根据 ESKF 中 5.3.3 The error-state kinematics 小节公式：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095306841.jpg)



#### 连续形式下 PVQ 增量的误差状态方程

![image-20210904190525077](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904190525077.png)

其中，$F^{15✖15}_{t}, G^{15✖12}_{t}, \delta^{15✖1}_{t}, n^{12✖1}_{t}$：

![image-20210904190548993](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904190548993.png)

简写为：

![image-20210904190629351](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904190629351.png)

根据导数定义可知：

![image-20210904190655635](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904190655635.png)

所以：

![image-20210904190715431](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904190715431.png)

令：

![image-20210904191001636](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904191001636.png)



IMU 误差运动方程再说明，将上式和 EKF 对比可知，上式恰好 给出了如 EKF 一般对非线性系统线性化的过程，这里的意义是表示下一个时刻的 IMU 测 量误差与上一个时刻的误差成线性关系，这样我们根据当前时刻的值，可以预测出下一个时刻 的均值和协方差，而上公式给出的是均值预测，协方差预测公式如下：

![image-20210904102248271](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904102248271.png)

上式给出了协方差的迭代公式，初始值$P^{b_k}_{b_k}=0$。其中，Q 为表示噪声项的对角协方差 矩阵：

![image-20210904191045225](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904191045225.png)

根据IMU误差方程式可获得误差项的 Jacobian 的迭代公式：

![image-20210904102536938](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904102536938.png)

其中 Jacobian 的初始值为$J_{b_k}=I$。这里计算出来的$J_{b_{k+1}}$只是为了给后面提供对 bias 的 Jacobian。



#### 离散形式中值积分的 PVQ 增量误差状态方程

代码中也是使用的离散状态下中值积分的PVQ增量误差状态方程，这和代码中 midPointIntegration()函数是一致的。

对于中值积分下的误差状态方程为：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095328390.jpg)

简写为：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095418315.png)

所以：

![img](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095509177.jpg)

展开得（稍微改变一下顺序，和代码对应）：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095525633.png)

其中：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513095644564.jpg)

令：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513100503906.jpg)

则IMU误差方程最终简写为：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513100534945.jpg)

此处 F′ 即代码中 F，相关代码见 midPointIntegration。



最后得到 IMU 预积分测量关于 IMU Bias 的 雅克比矩阵、IMU 预积分测量的协方差矩阵 和 噪声的 协方差矩阵 Q，初始状态下的雅克比矩阵和协方差矩阵为单位阵和零矩阵：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513100607569.jpg)

也给出了雅可比和协方差的迭代公式，初始值为$J_{b_k}=I$，$P^{b_k}_{b_k}=0$。其中，Q 为表示噪声项的对角协方差矩阵：

![image-20210904103317405](%E5%9B%BE%E8%A1%A8%E5%BA%93/image-20210904103317405.png)



当 bias 估计轻微改变时，我们可以使用如下的一阶近似对中值积分得到的预积分测量值进行矫正，而不重传播，从而得到更加精确的预积分测量值（ bias 修正的线性模型）：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513100706733.jpg)

此时，可以与卡尔曼滤波对比一下：

![在这里插入图片描述](%E5%9B%BE%E8%A1%A8%E5%BA%93/20190513100739271.jpg)



